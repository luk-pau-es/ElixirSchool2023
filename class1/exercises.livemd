# Exercises

## FizzBuzz

Write a function that returns the numbers from 1 to `n`. But for multiples of:

* three replaces a number with an atom `:fizz` instead of the number
* five replaces a number with an atom `:buzz`
* both three and five replaces a number with an atom `:fizzbuzz`.

Tip: see [How to use div/2 and/or rem/2?](https://elixir-lang.org/getting-started/basic-types.html#basic-arithmetic)

```elixir
# Simple solution
defmodule FizzBuzz do
  defp fizzbuzz_mapping(n) when rem(n, 15) == 0, do: :fizzbuzz
  defp fizzbuzz_mapping(n) when rem(n, 3) == 0, do: :fizz
  defp fizzbuzz_mapping(n) when rem(n, 5) == 0, do: :buzz
  defp fizzbuzz_mapping(n), do: n

  def fizzbuzz(0), do: []

  def fizzbuzz(n) do
    1..n
    |> Enum.to_list()
    |> Enum.map(&fizzbuzz_mapping/1)
  end
end

# Extendible solution
defmodule FizzBuzzExtendible do
  defp fizzbuzz_prime_3({n, output}) when rem(n, 3) == 0, do: {n, output <> "fizz"}
  defp fizzbuzz_prime_3({n, output}), do: {n, output}
  defp fizzbuzz_prime_5({n, output}) when rem(n, 5) == 0, do: {n, output <> "buzz"}
  defp fizzbuzz_prime_5({n, output}), do: {n, output}
  defp fizzbuzz_prime_7({n, output}) when rem(n, 7) == 0, do: {n, output <> "muzz"}
  defp fizzbuzz_prime_7({n, output}), do: {n, output}
  defp fizzbuzz_prime_11({n, output}) when rem(n, 11) == 0, do: {n, output <> "huzz"}
  defp fizzbuzz_prime_11({n, output}), do: {n, output}

  defp fizzbuzz_result({n, output}) when output == "", do: n
  defp fizzbuzz_result({_n, output}), do: :"#{output}"

  defp fizzbuzz_mapping(n) do
    {n, ""}
    |> fizzbuzz_prime_3
    |> fizzbuzz_prime_5
    |> fizzbuzz_prime_7
    |> fizzbuzz_prime_11
    |> fizzbuzz_result
  end

  def fizzbuzz(0), do: []

  def fizzbuzz(n) do
    1..n
    |> Enum.to_list()
    |> Enum.map(&fizzbuzz_mapping/1)
  end
end
```

```elixir
[] = FizzBuzz.fizzbuzz(0)
[1] = FizzBuzz.fizzbuzz(1)
[1, 2] = FizzBuzz.fizzbuzz(2)
[1, 2, :fizz] = FizzBuzz.fizzbuzz(3)

[
  1,
  2,
  :fizz,
  4,
  :buzz,
  :fizz,
  7,
  8,
  :fizz,
  :buzz,
  11,
  :fizz,
  13,
  14,
  :fizzbuzz,
  16,
  17,
  :fizz,
  19,
  :buzz,
  :fizz,
  22,
  23,
  :fizz,
  :buzz,
  26,
  :fizz,
  28,
  29,
  :fizzbuzz,
  31
] = FizzBuzz.fizzbuzz(31)
```

```elixir
# Bonus
FizzBuzzExtendible.fizzbuzz(3 * 5 * 7 * 11)
```

## Modules and Functions - Sum

Write functions `sum(n)` that uses recursion to calculate the sum of integers from 1 to n.

```elixir
defmodule Recursive do
  def sum(0), do: 0
  def sum(n), do: n + sum(n - 1)
end
```

```elixir
6 = Recursive.sum(3)
```

## Pipe operator - Scrabble Score

Given a word, compute the Scrabble score of that word.

### Letter Values

| Letter                       | Value |
| ---------------------------- | ----- |
| A, E, I, O, U, L, N, R, S, T | 1     |
| D, G                         | 2     |
| B, C, M, P                   | 3     |
| F, H, V, W, Y                | 4     |
| K                            | 5     |
| J, X                         | 8     |
| Q, Z                         | 10    |

Tip: You can calculate score for each group in separate function and pipe them together

```elixir
defmodule Scrabble do
  defp get_letter_value(letter) when letter in ["A", "E", "I", "O", "U", "L", "N", "R", "S", "T"],
    do: 1

  defp get_letter_value(letter) when letter in ["D", "G"], do: 2
  defp get_letter_value(letter) when letter in ["B", "C", "M", "P"], do: 3
  defp get_letter_value(letter) when letter in ["F", "H", "V", "W", "Y"], do: 4
  defp get_letter_value(letter) when letter in ["K"], do: 5
  defp get_letter_value(letter) when letter in ["J", "X"], do: 8
  defp get_letter_value(letter) when letter in ["Q", "Z"], do: 10

  def calculate_score(word) do
    word
    |> String.upcase()
    |> String.graphemes()
    |> Enum.map(&get_letter_value/1)
    |> Enum.sum()
  end
end
```

```elixir
14 = Scrabble.calculate_score("cabbage")
```
