# Processes DIY

## Echo process

Write code that will spawn another process, register this process under a given name (eg `:echo`) and make it reply whatever it receivers back to the sender.

Hint 0 - rememeber to register the echo process first.

Hint 1 - use recursion for looping.

Hint 2 - when a message is sent the sender process is unknown to the receiver process, therefore do not forget to include sender's PID in the message.

```elixir
defmodule Echo do
  defp echo_recursive do
    receive do
      {pid, msg} ->
        send(pid, msg)
        echo_recursive()
    after
      # Kill process after 1 second
      1000 -> IO.inspect(:timeout, label: "No more messages to echo")
    end
  end

  def spawn_echo_process do
    Process.register(self(), :echo)
    echo_recursive()
    Process.unregister(:echo)
  end
end
```

```elixir
# Unregister echo if that atom is registered
# Process.unregister(:echo)
```

```elixir
spawn(Echo, :spawn_echo_process, [])

messages = [:first, {:second, :message}, %{"third" => 1}]

for msg <- messages do
  send(:echo, {self(), msg})

  receive do
    ^msg -> :ok
    msg -> {:error, "Unexpected message #{inspect(msg)}"}
  after
    100 -> :timeout
  end
end
```

## Counter process

Implement a process that will work as a counter. It allows for incremenitng 1, incremating and decrementing by any numer or return current value.

Hint 0 - use recursion for looping.

Hint 1 - use recursive function's argument to store the state.

Hint 2 - use asyncronious comunication to update counter and syncronious communication to retrive current counter's value.

Hint 3 - think about possible race condition that may occure in your system.

```elixir
defmodule Counter do
  defp counter_recursive(count) do
    receive do
      :increment ->
        counter_recursive(count + 1)

      :decrement ->
        counter_recursive(count - 1)

      {:increment, number} ->
        counter_recursive(count + number)

      {:decrement, number} ->
        counter_recursive(count - number)

      {:retrive, pid} ->
        send(pid, count)
        counter_recursive(count)

      :stop ->
        :ok

      :throw ->
        throw(1)

      :exit ->
        exit(1)

      :error_internal ->
        1 = 2

      _ ->
        counter_recursive(count)
    end
  end

  def counter(), do: counter(0)

  def counter(count) do
    Process.register(self(), CounterProcess)
    counter_recursive(count)
    Process.unregister(CounterProcess)
  end
end
```

```elixir
spawn(Counter, :counter, [0])
```

```elixir
for _ <- Enum.to_list(1..1_000) do
  send(CounterProcess, :increment)
end

send(CounterProcess, :decrement)

send(CounterProcess, {:retrive, self()})

receive do
  msg -> IO.inspect(msg)
end

Process.sleep(500)

send(CounterProcess, {:retrive, self()})

receive do
  msg -> IO.inspect(msg)
end
```

## Warden

Implement a process that will start and watch counter process, if the counter crushes it the warden will restart it. With an inintial value.

Hint 1 - use monitor or link with setting process flag `trap_exit`.

```elixir
defmodule Warden do
  def warden_process(process_name, {module_name, function_name, function_arguments}) do
    Process.monitor(process_name)

    receive do
      msg ->
        IO.inspect(msg, label: "The trap exit messge")
        spawn(module_name, function_name, function_arguments)
    end

    warden_process(process_name, {module_name, function_name, function_arguments})
  end
end
```

```elixir
spawn(Warden, :warden_process, [CounterProcess, {Counter, :counter, []}])
```

```elixir
send(CounterProcess, :error_internal)
```

```elixir
send(CounterProcess, {:retrive, self()})

receive do
  msg -> IO.inspect(msg)
end
```

## The ring

One Ring to rule them all,
One Ring to find them,
One Ring to bring them all and in the darkness bind them.

Implement a ring of n (where n is positive integer > 2) processes,
The 1st process is forwarding a message to the second one,
the second one to the 3ed one etc

```mermaid
graph LR;
      1 --> 2;
      2 --> 3;
      3 --> ...;
      ... --> n;
      n --> 1;

```

```elixir
defmodule TheRing do
  def chinese_whispers(name, next_whisperer) do
    receive do
      :exit ->
        send(next_whisperer, :exit)
        IO.puts(name <> " exited gracefully")
        :ok

      recived_whisper ->
        IO.puts(name <> " received: " <> recived_whisper)
        Process.sleep(1000)
        send(next_whisperer, recived_whisper)
        chinese_whispers(name, next_whisperer)
    end
  end

  def setup(name) do
    receive do
      next_whisperer ->
        chinese_whispers(name, next_whisperer)
    end
  end

  def spawn_nodes(0, last_pid) do
    last_pid
  end

  def spawn_nodes(number, last_pid) do
    new_pid = spawn(TheRing, :chinese_whispers, ["#{number}", last_pid])
    spawn_nodes(number - 1, new_pid)
  end

  def create_the_ring(number) do
    first_process_id = spawn(TheRing, :setup, ["#{number}"])
    last_process_id = spawn_nodes(number - 1, first_process_id)
    send(first_process_id, last_process_id)
    first_process_id
  end
end
```

```elixir
pid = TheRing.create_the_ring(5)
```

```elixir
send(pid, "Hello")
```

```elixir
send(pid, :exit)
```
